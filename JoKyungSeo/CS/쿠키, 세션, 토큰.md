#### 10/19

## 인증 방법 - 쿠키 / 세션 / 토큰

HTTP의 connectionless 특징으로 stateless 특징이 생기고 이로 인해 HTTP는 클라이언트의 상태(정보)를 저장하지 못한다.
따라서 이런 단점을 보완하기 위해 쿠키 / 세션 / 토큰 등을 사용한다.

<br>

### 쿠키 / 세션

쿠키는 클라이언트(로컬)에 ley-value쌍으로 저장되는 데이터 파일이다. 유효 기간 내에서는 브라우저가 종료되어도 남아있는다.
쿠키는 값을 그대로 보내기 때문에 보안에 취약하고, 용량 제한이 있으며, 사이즈가 커질수록 네트워크 부하가 심해진다.

세션은 서버에 데이터를 저장하기 때문에 쿠키보다 보안성이 좋다. 또한, 브라우저가 종료되거나 서버에서 해당 세션을 삭제할 수 있다.
하지만 서버에 데이터를 저장하므로 서버가 느려지거나 서버의 자원이 부족할 수 있다.
따라서 쿠키를 사용해서 서버 자원 낭비를 방지하고 웹사이트 속도를 높일 수 있다.

![Screenshot 2022-10-19 at 15 19 07](https://user-images.githubusercontent.com/80232260/196615584-75d1c4c9-f340-40d6-9e1e-a48eae6040dc.JPG)

![Screenshot 2022-10-19 at 15 20 22](https://user-images.githubusercontent.com/80232260/196615573-dd4fcadc-65f2-4bf0-98b5-2f0a6119661f.JPG)

```text
1) 클라이언트 ---(요청)---> 서버
2) 서버는 세션을 생성하고 관리한다.
3) 서버 ---(세션ID)---> 클라이언트
4) 클라이언트는 세션ID를 쿠키에 저장
5) 클라이언트 ---(요청/세션ID) ---> 서버
6) 서버는 요청으로 온 세션ID와 서버가 가진 세션ID을 비교해서 인증을 수행한다.
```

-> 이 과정에서 쿠키에 있는 세션ID는 유의미한 개인정보가 없지만 세션ID 자체를 해커가 탈취할 수 있다. <br>(하지만 이것은 서버에서 IP특정을 통해 해결 가능)

<br>

### 토큰

- 토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 **유일한** '토큰'을 부여한다.
- 기존 세션 기반 인증의 단점을 보완한다.
  - 기존 세션 기반 인증은 서버에서 세션정보를 가지고 있고(stateful) 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.
  - 클라이언트의 상태를 계속 유지하고(stateful) 사용하면 사용자가 증가함에 따라 성능 문제가 생기게 되고 확장성이 어렵다.
- 토큰은 클라이언트에 저장되기 때문에 서버의 부담이 줄일 수 있다.
- 앱에는 쿠키와 세션이 없기 때문에 앱에서는 토큰을 사용해서 인증한다.
- 인증이 필요한 구간에서 토큰을 보내면 되기 때문에 클라이언트 상태를 유지하지 않으므로 stateless하다.
- 토큰의 길이가 길기 때문에 인증요청이 많을 경우, 네트워크 부하가 심해질 수 있다.
- 토큰을 탈취당하면 대처하기 어렵기 때문에 유효기간을 설정한다.
- payload 자체는 암호화되지 않기 때문에 유저의 중요 정보를 담을 수 없다.
  ![image](https://user-images.githubusercontent.com/80232260/196617159-b7e0d21c-a887-4e53-882b-a786e65709e3.png)

```text
1) 사용자가 로그인한다.
2) 서버 ---(토큰)---> 클라이언트
3) 클라이언트는 토큰을 쿠키나 스토리지에 저장해둔다.
4) 클라이언트 ---(헤더:토큰)---> 서버
5) 서버는 토큰을 검증하고 요청에 응답한다.

```

참고사이트) [쿠키/세션/토큰](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)


## 인증 방법 - 쿠키 / 세션 / 토큰

HTTP의 connectionless 특징으로 stateless 특징이 생기고 이로 인해 HTTP는 클라이언트의 상태(정보)를 저장하지 못한다. 
따라서 이런 단점을 보완하기 위해 쿠키 / 세션 / 토큰 등을 사용한다.

<br>

### 쿠키 / 세션

쿠키는 클라이언트(로컬)에 ley-value쌍으로 저장되는 데이터 파일이다. 유효 기간 내에서는 브라우저가 종료되어도 남아있는다. 
쿠키는 값을 그대로 보내기 때문에 보안에 취약하고, 용량 제한이 있으며, 사이즈가 커질수록 네트워크 부하가 심해진다.

세션은 서버에 데이터를 저장하기 때문에 쿠키보다 보안성이 좋다. 또한, 브라우저가 종료되거나 서버에서 해당 세션을 삭제할 수 있다.
하지만 서버에 데이터를 저장하므로 서버가 느려지거나 서버의 자원이 부족할 수 있다.
따라서 쿠키를 사용해서 서버 자원 낭비를 방지하고 웹사이트 속도를 높일 수 있다.

![Screenshot 2022-10-19 at 15 19 07](https://user-images.githubusercontent.com/80232260/196615584-75d1c4c9-f340-40d6-9e1e-a48eae6040dc.JPG)

![Screenshot 2022-10-19 at 15 20 22](https://user-images.githubusercontent.com/80232260/196615573-dd4fcadc-65f2-4bf0-98b5-2f0a6119661f.JPG)


```text
1) 클라이언트 ---(요청)---> 서버
2) 서버는 세션을 생성하고 관리한다.
3) 서버 ---(세션ID)---> 클라이언트 
4) 클라이언트는 세션ID를 쿠키에 저장
5) 클라이언트 ---(요청/세션ID) ---> 서버
6) 서버는 요청으로 온 세션ID와 서버가 가진 세션ID을 비교해서 인증을 수행한다.
```


-> 이 과정에서 쿠키에 있는 세션ID는 유의미한 개인정보가 없지만 세션ID 자체를 해커가 탈취할 수 있다. <br>(하지만 이것은 서버에서 IP특정을 통해 해결 가능)

<br>

### 토큰
  - 토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 **유일한** '토큰'을 부여한다.
  - 기존 세션 기반 인증의 단점을 보완한다.
    - 기존 세션 기반 인증은 서버에서 세션정보를 가지고 있고(stateful) 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.
    - 클라이언트의 상태를 계속 유지하고(stateful) 사용하면 사용자가 증가함에 따라 성능 문제가 생기게 되고 확장성이 어렵다.
  - 토큰은 클라이언트에 저장되기 때문에 서버의 부담이 줄일 수 있다.
  - 앱에는 쿠키와 세션이 없기 때문에 앱에서는 토큰을 사용해서 인증한다.
  - 인증이 필요한 구간에서 토큰을 보내면 되기 때문에 클라이언트 상태를 유지하지 않으므로 stateless하다.
  - 토큰의 길이가 길기 때문에 인증요청이 많을 경우, 네트워크 부하가 심해질 수 있다.
  - 토큰을 탈취당하면 대처하기 어렵기 때문에 유효기간을 설정한다.
  - payload 자체는 암호화되지 않기 때문에 유저의 중요 정보를 담을 수 없다.
![image](https://user-images.githubusercontent.com/80232260/196617159-b7e0d21c-a887-4e53-882b-a786e65709e3.png)

```text
1) 사용자가 로그인한다.
2) 서버 ---(토큰)---> 클라이언트
3) 클라이언트는 토큰을 쿠키나 스토리지에 저장해둔다.
4) 클라이언트 ---(헤더:토큰)---> 서버
5) 서버는 토큰을 검증하고 요청에 응답한다.

```

<br>

## TCP vs UDP

TCP는 연결성 / 신뢰성 전송 프로토콜이며, 연결성을 위해서 데이터 전송 전에 3wayhadshaking으로 논리적인 연결을 하고, 연결을 종료할 때는 4wayhadshaking을 사용한다.
흐름제어, 오류제어, 혼잡제어를 통해 신뢰성 있는 전송을 하기 때문에 헤더가 UDP보다 크고 속도가 느리다.
따라서, 파일 전송같은 걸 할 때 TCP를 사용한다.

UDP는 비신뢰성 / 비연결성 전송 프로토콜로, TCP에서 하는 복잡한 과정은 하지 않기 때문에 헤더가 작고 속도가 빠르다.
그래서 실시간 스트리밍에 적합하다.

<br>

## HTTP에서 get과 post의 차이

get의 경우는 리소스를 조회하는 요청이며, qeury string으로 자원을 식별한다. 한번 요청을 하면 url이 웹 브라우저에 저장이 되어 다음에 같은 요청을 했을 때 캐싱된 데이터를 가져온다.
post의 경우는 리소스를 생성하는데에 자주 쓰이는 요청이고, request.body를 통해 데이터를 서버로 보내며, 캐싱되지 않는다.

<br>

## HTTP에서 patch와 put의 차이

둘 다 리소스를 수정할 때 사용하며, put은 리소스 전체를 바꾼다. 대체를 한다고도 할 수 있다. patch는 리소스의 일부를 수정한다.

  ``` javascript

  // put
  {
    name: "jo",
    gender: "female",
  }

  // 수정할 데이터로 name만 보낸다면, DB에서 봤을 때 gender는 null값이 된다.  
  {
    name: "Kim"
  }

  //\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

  // patch
  {
    name: "jo",
    gender: "female",
  }

  // 수정할 데이터로 name만 보내도, gender는 이전 값이 그대로 반영된다.  
  {
    name: "Kim",
    gender: "female",
  }

  ```  
